# Bytecode And Assembly

## Bytecode
```shell
javap -v javaClassFile
```
* [Introduction to Java Bytecode](https://dzone.com/articles/introduction-to-java-bytecode)

## JIT Assembly Code
* `-XX:+PrintCompilation` to show basic information on when Hotspot compiles methods.
  - [PrintCompilation JVM flag](https://blog.joda.org/2011/08/printcompilation-jvm-flag.html)
  - [Understanding the output of -XX:+PrintCompilation](https://stackoverflow.com/questions/13086690/understanding-the-output-of-xxprintcompilation)
  
* `-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly` to print all generated assembly code
  - [PrintAssembly](https://wiki.openjdk.java.net/display/HotSpot/PrintAssembly)
  - [[JVM] How to see Assembly code for your Java Program](https://www.ashishpaliwal.com/blog/2013/05/jvm-how-to-see-assembly-code-for-your-java-program/)
  - [PrintAssembly output explained!](http://jpbempel.blogspot.com/2015/12/printassembly-output-explained.html)
  - [How to Show the Assembly Code Generated by the JVM](https://www.beyondjava.net/show-assembly-code-generated-jvm)
  - [Printing Generated Assembly Code From The Hotspot JIT Compiler](https://mechanical-sympathy.blogspot.com/2013/06/printing-generated-assembly-code-from.html)
  - [How to use -XX:+UnlockDiagnosticVMOptions -XX:CompileCommand=print option with JVM HotSpot](https://stackoverflow.com/questions/9341083/how-to-use-xxunlockdiagnosticvmoptions-xxcompilecommand-print-option-with-j)
  - [java – 如何使用-XX：UnlockDiagnosticVMOptions -XX：CompileCommand =打印选项与JVM HotSpot](https://codeday.me/bug/20180728/206204.html)

### ComileCommand
* `-XX:UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining`
* `-XX:+PrintCompilation -XX:CompileCommand="print Class::method"`
* `-XX:+PrintCompilation -XX:CompileCommand="exclude Class::method"`
* ` -XX:+PrintCompilation -XX:CompileCommand="compileonly Class::method"`
* ` -XX:+UnlockDiagnosticVMOptions -XX:+LogCompilation`
* `-XX:CompileCommand="log Class::method"`
* `XX:CompileCommand="option Class::method"`
*  CompileCommandFile: `-XX:CompileCommandFile=MyCompilerFile.txt`

* [CompileCommand JVM option](http://jpbempel.blogspot.com/2016/03/compilecommand-jvm-option.html)

### JITWatch

* [Understanding Java JIT Compilation with JITWatch, Part 1](https://www.oracle.com/technetwork/articles/java/architect-evans-pt1-2266278.html)
* [Why it rocks to finally understand Java JIT with JITWatch](https://zeroturnaround.com/rebellabs/why-it-rocks-to-finally-understand-java-jit-with-jitwatch/)


### hsdis plugin
```shell
# Get hsdis source code for current java version
hg clone http://https://hg.openjdk.java.net/jdkX/jdkX  # X will be 6, 7, 8, 9, 10
cd jdkX
source get_source
cd hotspot/src/share/tools/hsdis/
# or just download the source, e.g. jdk10
wget https://hg.openjdk.java.net/jdk10/jdk10/hotspot/archive/5ab7a67bc155.zip/src/share/tools/hsdis/

# get binutils -- https://ftp.gnu.org/gnu/binutils/
# since binutils have changed the interface of disassembler function between 2.28 and 2.29
# 2.28: extern disassembler_ftype disassembler (bfd *);
# 2.29: extern disassembler_ftype disassembler (enum bfd_architecture arc,
#                                       bfd_boolean big, unsigned long mach,
#                                       bfd *abfd);

# except jdk8u
wget https://ftp.gnu.org/gnu/binutils/binutils-2.28.tar.gz

# for jdk8u can get binutils-2.29+
wget https://ftp.gnu.org/gnu/binutils/binutils-2.31.tar.gz

# or patch the hsdis.c file and build, may cause error.

# make
make BINUTILS=binutils-2.xx ARCH=amd64

# copy to jvm/server
# Mac OS x
sudo cp hsdis-amd64.dylib /Library/Java/JavaVirtualMachines/jdk-x.x.x.jdk/Contents/Home/lib/server
```
* [Building hsdis on Linux amd64 on Debian](https://www.chrisnewland.com/building-hsdis-on-linux-amd64-on-debian-369)
* [Building hsdis-amd64.dylib on Mac OSX](https://www.chrisnewland.com/building-hsdis-amd64dylib-on-mac-osx-376)
* [Updated instructions for building hsdis on OSX](https://www.chrisnewland.com/updated-instructions-for-building-hsdis-on-osx-417)

* [hsdis disassembler plugin does not compile with binutils 2.29+](https://bugs.openjdk.java.net/browse/JDK-8191006)
* [linux/bfd.c unable to compile with binutils 2.29](https://github.com/google/honggfuzz/issues/162)

## Examples

* [Why is 2 * (i * i) faster than 2 * i * i in Java?](https://stackoverflow.com/questions/53452713/why-is-2-i-i-faster-than-2-i-i-in-java)

> There is a slight difference in the ordering of the bytecode.  
> dig deeper into the lower level (JIT)  
> Remember that JIT tends to unroll small loops very aggressively.   
> The answer to the question is simple: 2 * (i * i) is faster than 2 * i * i because the JIT generates more optimal assembly code for the first case.


## References

